<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="manifest" href="manifest.json">
    <title>Squat Monitor - PoseNet</title>
    
    <!-- Load TensorFlow.js -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <!-- Load Posenet -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/posenet"></script>
    <!-- Load Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f0f2f5;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        h1 { margin-bottom: 10px; }

        /* Container for the live view */
        .viewer-container {
            position: relative;
            width: 100%; /* Take full width of its parent */
            max-width: 640px; /* Max width as before */
            padding-top: 75%; /* 4:3 Aspect Ratio (480 / 640 = 0.75) */
            height: 0; /* Important for padding-top trick */
            background: #000;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }

        video, canvas#output {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transform: scaleX(-1); /* Mirror the video and canvas */
        }
        video {
            display: none; /* Hidden, we draw to canvas */
        }

        .stats-overlay {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: #00ffcc;
            padding: 10px;
            border-radius: 4px;
            font-size: 18px;
            z-index: 10;
            pointer-events: none;
        }

        /* Layout for charts */
        .charts-wrapper {
            width: 100%;
            max-width: 1000px;
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px;
        }

        .chart-card {
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        .history-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-top: 20px;
        }

        @media (max-width: 800px) {
            .viewer-container { width: 100%; height: auto; aspect-ratio: 4/3; }
            canvas#output { width: 100%; height: 100%; }
            .history-grid { grid-template-columns: 1fr; }
        }

        .version {
            position: absolute;
            top: 5px;
            right: 5px;
            font-size: 10px;
            color: #888;
        }
    </style>
</head>
<body>
    <div class="version">v.1.0.1</div>
    <h1>Squat Angle Monitor v.1.0.1</h1>
    
    <button id="startStopButton">Start</button>

    <!-- Live Viewer -->
    <div class="viewer-container">
        <div class="stats-overlay">
            <div>Knee Angle: <span id="angleDisplay">0</span>Â°</div>
            <div>Status: <span id="statusDisplay">Standing</span></div>
            <div>Squats: <span id="countDisplay">0</span></div>
        </div>
        <video id="video" autoplay playsinline></video>
        <canvas id="output"></canvas>
    </div>

    <div class="charts-wrapper">
        <!-- Real-time graph for current squat -->
        <div class="chart-card">
            <h3>Current / Live Squat</h3>
            <canvas id="liveChart"></canvas>
        </div>

        <!-- History graphs -->
        <div class="history-grid">
            <div class="chart-card">
                <h4>Last Squat - 3</h4>
                <canvas id="histChart3"></canvas>
            </div>
            <div class="chart-card">
                <h4>Last Squat - 2</h4>
                <canvas id="histChart2"></canvas>
            </div>
            <div class="chart-card">
                <h4>Last Squat - 1 (Most Recent)</h4>
                <canvas id="histChart1"></canvas>
            </div>
        </div>
    </div>

    <script>
        /**
         * APP CONFIGURATION
         */
        const CONF = {
            videoWidth: 640,
            videoHeight: 480,
            flipHorizontal: true,
            minConfidence: 0.2, // Lowered from 0.5
            // Squat logic thresholds (in degrees)
            standThresh: 165, // Angle considered "Standing"
            squatThresh: 140, // Angle considered starting a squat
            deepThresh: 100,  // Just for visual feedback on deep squats
        };

        /**
         * STATE MANAGEMENT
         */
        let state = {
            isDetecting: false,
            isSquatting: false,
            squatCount: 0,
            currentAngle: 180,
            // Buffer for the current squat data
            currentSquatData: [], 
            startTime: 0,
            animationFrameId: null,
            videoStream: null,
            posenetModel: null
        };

        // Placeholder for chart instances
        let liveChart;
        const historyCharts = []; 

        const startStopButton = document.getElementById('startStopButton');
        startStopButton.onclick = toggleDetection;

        /**
         * INITIALIZATION
         */
        async function setup() {
            initCharts();
            console.log("Loading PoseNet...");
            state.posenetModel = await posenet.load({
                architecture: 'MobileNetV1',
                outputStride: 16,
                inputResolution: { width: 500, height: 500 },
                multiplier: 0.75
            });
            console.log("PoseNet Loaded");
        }

        async function toggleDetection() {
            if (state.isDetecting) {
                // Stop detection
                state.isDetecting = false;
                startStopButton.innerText = 'Start';
                if (state.animationFrameId) {
                    cancelAnimationFrame(state.animationFrameId);
                }
                if (state.videoStream) {
                    state.videoStream.getTracks().forEach(track => track.stop());
                }
                const canvas = document.getElementById('output');
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
            } else {
                // Start detection
                state.isDetecting = true;
                startStopButton.innerText = 'Stop';
                const video = document.getElementById('video');
                try {
                    state.videoStream = await navigator.mediaDevices.getUserMedia({
                        'audio': false,
                        'video': {
                            width: CONF.videoWidth,
                            height: CONF.videoHeight,
                            facingMode: 'user'
                        }
                    });
                    video.srcObject = state.videoStream;

                    video.onloadedmetadata = () => {
                        CONF.videoWidth = video.videoWidth;
                        CONF.videoHeight = video.videoHeight;
                        const canvas = document.getElementById('output');
                        const ctx = canvas.getContext('2d');
                        canvas.width = CONF.videoWidth;
                        canvas.height = CONF.videoHeight;
                        detectPoseInRealTime(video, state.posenetModel, ctx);
                    };
                } catch (e) {
                    console.error("Error starting video stream:", e);
                    state.isDetecting = false;
                    startStopButton.innerText = 'Start';
                }
            }
        }
        
        /**
         * MAIN LOOP
         */
        function detectPoseInRealTime(video, net, ctx) {
            async function poseDetectionFrame() {
                if (!state.isDetecting) return;

                const pose = await net.estimateSinglePose(video, {
                    flipHorizontal: false 
                });

                ctx.clearRect(0, 0, CONF.videoWidth, CONF.videoHeight);
                ctx.save();
                ctx.drawImage(video, 0, 0, CONF.videoWidth, CONF.videoHeight);
                
                drawKeypoints(pose.keypoints, CONF.minConfidence, ctx);
                drawSkeleton(pose.keypoints, CONF.minConfidence, ctx);
                ctx.restore();

                processPose(pose);

                state.animationFrameId = requestAnimationFrame(poseDetectionFrame);
            }
            poseDetectionFrame();
        }

        /**
         * LOGIC: Angle Calculation & Squat State Machine
         */
        function processPose(pose) {
            const rightHip = pose.keypoints.find(k => k.part === 'rightHip');
            const rightKnee = pose.keypoints.find(k => k.part === 'rightKnee');
            const rightAnkle = pose.keypoints.find(k => k.part === 'rightAnkle');
            
            const leftHip = pose.keypoints.find(k => k.part === 'leftHip');
            const leftKnee = pose.keypoints.find(k => k.part === 'leftKnee');
            const leftAnkle = pose.keypoints.find(k => k.part === 'leftAnkle');

            const rightConf = (rightHip.score + rightKnee.score + rightAnkle.score) / 3;
            const leftConf = (leftHip.score + leftKnee.score + leftAnkle.score) / 3;

            let hip, knee, ankle;

            if (rightConf > leftConf && rightConf > CONF.minConfidence) {
                [hip, knee, ankle] = [rightHip, rightKnee, rightAnkle];
            } else if (leftConf > CONF.minConfidence) {
                [hip, knee, ankle] = [leftHip, leftKnee, leftAnkle];
            } else {
                return;
            }

            const angle = calculateAngle(hip.position, knee.position, ankle.position);
            state.currentAngle = Math.round(angle);

            document.getElementById('angleDisplay').innerText = state.currentAngle;
            document.getElementById('angleDisplay').style.color = state.currentAngle < CONF.deepThresh ? '#00ff00' : '#00ffcc';

            const now = Date.now();

            if (!state.isSquatting) {
                if (angle < CONF.squatThresh) {
                    state.isSquatting = true;
                    state.startTime = now;
                    state.currentSquatData = []; 
                    document.getElementById('statusDisplay').innerText = "Squatting...";
                    resetLiveChart();
                }
            }

            if (state.isSquatting) {
                const timeOffset = (now - state.startTime) / 1000;
                state.currentSquatData.push({ x: timeOffset, y: Math.round(angle) });
                
                updateLiveChart(timeOffset, Math.round(angle));

                if (angle > CONF.standThresh) {
                    state.isSquatting = false;
                    state.squatCount++;
                    document.getElementById('statusDisplay').innerText = "Standing";
                    document.getElementById('countDisplay').innerText = state.squatCount;
                    
                    pushToHistory(state.currentSquatData);
                }
            }
        }

        /**
         * MATH: Calculate angle between three points (A-B-C)
         */
        function calculateAngle(a, b, c) {
            const AB = Math.sqrt(Math.pow(b.x - a.x, 2) + Math.pow(b.y - a.y, 2));
            const BC = Math.sqrt(Math.pow(b.x - c.x, 2) + Math.pow(b.y - c.y, 2));
            const AC = Math.sqrt(Math.pow(c.x - a.x, 2) + Math.pow(c.y - a.y, 2));
            
            let radian = Math.acos((BC*BC+AB*AB-AC*AC)/(2*BC*AB));
            let degree = (radian * 180) / Math.PI;
            
            return degree; 
        }

        /**
         * CHARTING LOGIC
         */
        function initCharts() {
            loadHistory();

            const commonOptions = {
                responsive: true,
                animation: false, 
                scales: {
                    y: { 
                        beginAtZero: false, 
                        min: 40, max: 180,
                        title: { display: true, text: 'Angle (Degrees)' }
                    },
                    x: {
                        type: 'linear',
                        title: { display: true, text: 'Time (s)' }
                    }
                },
                plugins: { legend: { display: false } }
            };

            const ctxLive = document.getElementById('liveChart').getContext('2d');
            liveChart = new Chart(ctxLive, {
                type: 'line',
                data: { datasets: [{ label: 'Live Angle', data: [], borderColor: 'rgb(75, 192, 192)', tension: 0.1 }] },
                options: commonOptions
            });

            const ids = ['histChart1', 'histChart2', 'histChart3'];
            ids.forEach(id => {
                const ctx = document.getElementById(id).getContext('2d');
                historyCharts.push(new Chart(ctx, {
                    type: 'line',
                    data: { datasets: [{ label: 'Squat', data: [], borderColor: '#ff6384', tension: 0.1 }] },
                    options: {
                        ...commonOptions,
                        scales: { y: { display: true, min: 40, max: 180 }, x: { display: true, type: 'linear', title: { display: true, text: 'Time (s)' } } }
                    }
                }));
            });
        }

        function updateLiveChart(time, angle) {
            liveChart.data.datasets[0].data.push({x: time, y: angle});
            if(liveChart.data.datasets[0].data.length > 300) {
                liveChart.data.datasets[0].data.shift();
            }
            liveChart.update('none'); 
        }

        function resetLiveChart() {
            liveChart.data.datasets[0].data = [];
            liveChart.update();
        }

        function pushToHistory(data) {
            const historyData = loadHistoryData() || [];

            historyData.unshift({
                timestamp: new Date().toISOString(),
                data: data
            });

            if (historyData.length > 3) {
                historyData.pop();
            }

            saveHistoryData(historyData);
            updateHistoryCharts(historyData);
        }

        function loadHistory() {
            const historyData = loadHistoryData();
            if (historyData) {
                updateHistoryCharts(historyData);
            }
        }

        function loadHistoryData() {
            const jsonData = localStorage.getItem('squatHistory');
            return jsonData ? JSON.parse(jsonData) : null;
        }

        function saveHistoryData(historyData) {
            localStorage.setItem('squatHistory', JSON.stringify(historyData));
        }

        function updateHistoryCharts(historyData) {
            for (let i = 0; i < historyCharts.length; i++) {
                if (historyData[i]) {
                    historyCharts[i].data.datasets[0].data = historyData[i].data;
                    historyCharts[i].update();
                }
            }
        }

        /**
         * DRAWING HELPERS (Standard PoseNet Utils)
         */
        function drawKeypoints(keypoints, minConfidence, ctx) {
            keypoints.forEach((keypoint) => {
                if (keypoint.score >= minConfidence) {
                    const { y, x } = keypoint.position;
                    ctx.beginPath();
                    ctx.arc(x, y, 5, 0, 2 * Math.PI);
                    ctx.fillStyle = '#00ffcc';
                    ctx.fill();
                }
            });
        }

        function drawSkeleton(keypoints, minConfidence, ctx) {
            const adjacentKeyPoints = posenet.getAdjacentKeyPoints(keypoints, minConfidence);
            adjacentKeyPoints.forEach((keypoints) => {
                drawSegment(
                    toTuple(keypoints[0].position), 
                    toTuple(keypoints[1].position), 
                    '#00ffcc', 
                    ctx
                );
            });
        }

        function toTuple({ y, x }) { return [y, x]; }

        function drawSegment([ay, ax], [by, bx], color, ctx) {
            ctx.beginPath();
            ctx.moveTo(ax, ay);
            ctx.lineTo(bx, by);
            ctx.lineWidth = 2;
            ctx.strokeStyle = color;
            ctx.stroke();
        }

        // Start App
        setup();

    </script>
    <script>
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/sw.js').then(registration => {
                    console.log('ServiceWorker registration successful with scope: ', registration.scope);
                }, err => {
                    console.log('ServiceWorker registration failed: ', err);
                });
            });
        }
    </script>
</body>
</html>