<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="manifest" href="manifest.json">
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <link rel="apple-touch-icon" sizes="512x512" href="app-icon.svg">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
    <title>Squat Meter - AI Squat Angle Monitor & Form Tracker</title>
    <meta name="description" content="Free online squat angle monitor and form tracker. Use your webcam to measure squat depth in real-time with AI. No equipment needed.">
    <meta name="keywords" content="squat angle monitor, squat depth tracker, AI squat analysis, webcam fitness tool, powerlifting depth check, home workout assistant">

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://squat-meter.com/">
    <meta property="og:title" content="Squat Meter - AI Squat Angle Monitor">
    <meta property="og:description" content="Real-time squat analysis using your webcam. Measure knee angles, count reps, and track depth automatically.">
    <meta property="og:image" content="app-icon.svg">

    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:title" content="Squat Meter - AI Squat Angle Monitor">
    <meta property="twitter:description" content="Real-time squat analysis using your webcam. Measure knee angles, count reps, and track depth automatically.">
    <meta property="twitter:image" content="app-icon.svg">

    <!-- JSON-LD Structured Data -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "SoftwareApplication",
      "name": "Squat Meter",
      "applicationCategory": "HealthApplication",
      "operatingSystem": "Any",
      "offers": {
        "@type": "Offer",
        "price": "0",
        "priceCurrency": "USD"
      },
      "description": "A real-time AI squat angle monitor that uses your webcam to track squat depth and form.",
      "featureList": "Real-time knee angle measurement, Squat repetition counting, Depth analysis, Privacy-focused (local processing)"
    }
    </script>
    
    <!-- Load TensorFlow.js -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <!-- Load MoveNet -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection"></script>
    <!-- Load Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <style>
        :root {
            --md-bg: #f6f5fb;
            --md-surface: #ffffff;
            --md-surface-alt: #fef7ff;
            --md-outline: rgba(22, 22, 22, 0.08);
            --md-primary: #6750a4;
            --md-primary-dark: #4f378b;
            --md-secondary: #03dac6;
            --md-error: #b3261e;
            --md-text: #1d1b20;
            --md-muted: #5f5f5f;
        }

        body {
            font-family: 'Roboto', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--md-bg);
            color: var(--md-text);
            margin: 0;
            padding: 32px;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }

        .app-shell {
            width: 100%;
            max-width: 720px;
            display: flex;
            flex-direction: column;
            gap: 24px;
            position: relative;
            z-index: 1;
        }

        h1 {
            margin: 0;
            font-size: 1.35rem;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            color: var(--md-primary-dark);
        }

        .header-subtitle {
            font-size: 0.85rem;
            color: var(--md-muted);
            margin-top: 4px;
            font-weight: 500;
            line-height: 1.3;
            max-width: 600px;
        }

        .header-container {
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-sizing: border-box;
            padding: 20px 28px;
            background: var(--md-surface-alt);
            border-radius: 28px;
            box-shadow: 0 18px 40px rgba(15, 15, 15, 0.08);
        }

        /* Container for the live view */
        .viewer-container {
            position: relative;
            width: 100%;
            padding-top: 75%; /* 4:3 Aspect Ratio (480 / 640 = 0.75) */
            height: 0;
            background: linear-gradient(135deg, rgba(103,80,164,0.8), rgba(3,218,198,0.55));
            border-radius: 32px;
            overflow: hidden;
            box-shadow: 0 24px 60px rgba(15, 15, 15, 0.18);
            box-sizing: border-box;
        }

        video, canvas#output {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        video {
            display: none; /* Hidden, we draw to canvas */
        }

        .stats-overlay {
            position: absolute;
            top: 16px;
            left: 16px;
            background: rgba(255, 255, 255, 0.92);
            color: var(--md-muted);
            padding: 14px 18px;
            border-radius: 20px;
            font-size: 0.95rem;
            z-index: 10;
            pointer-events: none;
            box-shadow: 0 12px 24px rgba(15, 15, 15, 0.2);
            backdrop-filter: blur(6px);
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .stats-overlay div {
            display: flex;
            justify-content: space-between;
            gap: 12px;
        }

        .stats-overlay span {
            font-weight: 600;
            color: var(--md-primary-dark);
        }

        .instruction-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 40px;
            box-sizing: border-box;
            text-align: center;
            z-index: 5;
            background: linear-gradient(135deg, rgba(15, 15, 15, 0.9), rgba(25, 25, 25, 0.65));
            color: white;
            backdrop-filter: blur(4px);
        }

        .instruction-screen.hidden {
            display: none;
        }

        .loading-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 6;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            backdrop-filter: blur(4px);
        }

        .loading-screen.hidden {
            display: none;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: var(--md-secondary);
            animation: spin 1s ease-in-out infinite;
            margin-bottom: 16px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .instruction-text {
            color: #fff;
            font-size: 1.1rem;
            line-height: 1.6;
            margin-bottom: 24px;
            max-width: 420px;
        }

        .instruction-screen button {
            padding: 14px 48px;
            font-size: 1rem;
            cursor: pointer;
            border: none;
            border-radius: 999px;
            background: var(--md-secondary);
            color: #042f2e;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            box-shadow: 0 18px 35px rgba(3, 218, 198, 0.4);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .instruction-screen button:hover {
            transform: translateY(-1px);
            box-shadow: 0 20px 40px rgba(3, 218, 198, 0.5);
        }

        .stop-overlay {
            position: absolute;
            top: 16px;
            right: 16px;
            z-index: 15;
            display: flex;
            gap: 12px;
            background: transparent;
            padding: 0;
            border-radius: 0;
            backdrop-filter: none;
            box-shadow: none;
        }

        .stop-overlay.hidden {
            display: none;
        }

        .stats-overlay.hidden {
            display: none;
        }

        .stop-overlay button {
            padding: 10px 20px;
            font-size: 0.85rem;
            cursor: pointer;
            border: none;
            border-radius: 999px;
            font-weight: 600;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            transition: transform 0.15s ease, box-shadow 0.15s ease;
        }

        .stop-overlay button.stop-btn {
            background: linear-gradient(120deg, var(--md-error), #7f1d1d);
            color: #fff;
            box-shadow: 0 10px 24px rgba(179, 38, 30, 0.45);
        }

        .stop-overlay button.stop-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 12px 26px rgba(179, 38, 30, 0.6);
        }

        .stop-overlay button.reset-btn {
            background: rgba(255, 255, 255, 0.9);
            color: var(--md-primary-dark);
            box-shadow: 0 8px 20px rgba(15, 15, 15, 0.2);
        }

        .stop-overlay button.reset-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 10px 24px rgba(15, 15, 15, 0.25);
        }

        /* Layout for charts */
        .charts-wrapper {
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 24px;
            box-sizing: border-box;
        }

        .chart-card {
            background: var(--md-surface);
            padding: 20px 24px;
            border-radius: 28px;
            box-shadow: 0 16px 40px rgba(15, 15, 15, 0.08);
            box-sizing: border-box;
            width: 100%;
            min-width: 0;
            border: 1px solid var(--md-outline);
        }

        .chart-card.hidden {
            display: none;
        }

        .show-all-card {
            position: relative;
            overflow: hidden;
        }

        .chart-card h3 {
            margin: 0 0 12px;
            font-weight: 600;
            letter-spacing: 0.05em;
            color: var(--md-primary-dark);
            text-transform: uppercase;
            font-size: 0.95rem;
        }

        .history-viewer {
            margin-top: 0;
            display: block;
        }

        .history-viewer.hidden {
            display: none;
        }

        .history-controls {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-bottom: 16px;
        }

        .history-controls h4 {
            margin: 0;
            font-size: 0.9em;
            letter-spacing: 0.04em;
            color: var(--md-muted);
            font-weight: 500;
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
        }

        .nav-buttons {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            gap: 12px;
        }

        .nav-arrows {
            display: flex;
            gap: 10px;
        }

        .nav-buttons button,
        .delete-btn {
            width: 44px;
            height: 44px;
            font-size: 1rem;
            cursor: pointer;
            border-radius: 16px;
            border: 1px solid var(--md-outline);
            background: var(--md-surface);
            color: var(--md-primary-dark);
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 10px 24px rgba(15, 15, 15, 0.15);
            transition: transform 0.15s ease, box-shadow 0.15s ease, background 0.15s ease;
        }

        .nav-buttons button:hover,
        .delete-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 12px 26px rgba(15, 15, 15, 0.2);
        }

        .nav-buttons button:disabled {
            background: #e4e1ec;
            color: #b1a7c8;
            cursor: not-allowed;
            box-shadow: none;
        }

        .delete-btn {
            background: linear-gradient(135deg, var(--md-error), #7f1d1d);
            color: #fff;
            border: none;
        }

        .card-delete-btn {
            position: absolute;
            bottom: 12px;
            right: 12px;
            width: 40px;
            height: 40px;
            font-size: 0.9rem;
            z-index: 2;
            opacity: 0.95;
            background: var(--md-surface);
            color: var(--md-primary-dark);
            border: 1px solid var(--md-outline);
            box-shadow: 0 10px 24px rgba(15, 15, 15, 0.2);
        }

        .card-delete-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 12px 26px rgba(15, 15, 15, 0.25);
        }

        .all-squats-grid {
            display: none;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 24px;
            margin-top: 12px;
        }

        .all-squats-grid.visible {
            display: grid;
        }

        .bottom-controls {
            width: 100%;
            margin-top: 8px;
            display: flex;
            gap: 16px;
            justify-content: center;
            box-sizing: border-box;
        }

        .bottom-controls button {
            padding: 14px 24px;
            font-size: 0.95rem;
            cursor: pointer;
            border: none;
            border-radius: 999px;
            background: var(--md-primary);
            color: white;
            letter-spacing: 0.06em;
            text-transform: uppercase;
            font-weight: 600;
            flex: 1;
            box-shadow: 0 18px 40px rgba(103, 80, 164, 0.35);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .bottom-controls button:hover {
            transform: translateY(-1px);
            box-shadow: 0 22px 45px rgba(103, 80, 164, 0.45);
        }

        .bottom-controls button.delete-all {
            background: var(--md-error);
            box-shadow: 0 18px 40px rgba(179, 38, 30, 0.45);
        }

        .bottom-controls button.delete-all:hover {
            box-shadow: 0 22px 48px rgba(179, 38, 30, 0.55);
        }

        @media (max-width: 800px) {
            body { padding: 20px; }
            .app-shell { max-width: 100%; }
            .header-container,
            .chart-card { border-radius: 20px; padding: 18px; }
            .viewer-container { width: 100%; height: auto; aspect-ratio: 4/3; border-radius: 24px; }
            canvas#output { width: 100%; height: 100%; }
            .all-squats-grid { grid-template-columns: 1fr; }
            .stop-overlay { flex-direction: column; right: 12px; }
            .bottom-controls { flex-direction: column; }
            .bottom-controls button { width: 100%; }
        }

        .version-tag {
            position: fixed;
            top: 4px;
            right: 10px;
            font-size: 0.65rem;
            color: rgba(93, 93, 107, 0.7);
            letter-spacing: 0.16em;
            text-transform: uppercase;
            pointer-events: none;
            z-index: 0;
        }
    </style>
</head>
<body>
    <div class="version-tag">v.__DEPLOY_VERSION__</div>
    <div class="app-shell">
    <div class="header-container">
        <div>
            <h1>Squat Angle Monitor</h1>
            <div class="header-subtitle">Free AI Squat Angle Monitor. Track your squat depth and form in real-time using your webcam.</div>
        </div>
    </div>

    <!-- Live Viewer -->
    <div class="viewer-container">
        <div class="loading-screen hidden" id="loadingScreen">
            <div class="spinner"></div>
            <div id="loadingText">Initializing...</div>
        </div>
        <div class="instruction-screen" id="instructionScreen">
            <div class="instruction-text">
                Place the camera so it can see your full figure from the side. Then do your squat set.
            </div>
            <button onclick="toggleDetection()">Start</button>
        </div>
        <div class="stop-overlay hidden" id="stopOverlay">
            <button class="reset-btn" onclick="resetLiveData()">Reset</button>
            <button class="stop-btn" onclick="toggleDetection()">Stop</button>
        </div>
        <div class="stats-overlay hidden" id="statsOverlay">
            <div>Knee Angle: <span id="angleDisplay">0</span></div>
            <div>Status: <span id="statusDisplay">Standing</span></div>
            <div>Squats: <span id="countDisplay">0</span></div>
        </div>
        <video id="video" autoplay playsinline></video>
        <canvas id="output"></canvas>
    </div>

    <div class="charts-wrapper">
        <!-- Real-time graph for current squat -->
        <div class="chart-card hidden" id="liveChartCard">
            <h3>Current / Live Squat</h3>
            <canvas id="liveChart"></canvas>
        </div>

        <!-- Single History Viewer -->
        <div class="chart-card history-viewer" id="historyViewer">
            <div class="history-controls">
                <h4 id="historyTitle">No Squats Recorded</h4>
                <div class="nav-buttons">
                    <div class="nav-arrows">
                        <button id="prevBtn" onclick="navigateHistory(-1)" title="Previous">â¬†</button>
                        <button id="nextBtn" onclick="navigateHistory(1)" title="Next">â¬‡</button>
                    </div>
                    <button class="delete-btn" id="deleteBtn" onclick="deleteCurrentSquat()" title="Delete">ðŸ—‘</button>
                </div>
            </div>
            <canvas id="historyChart"></canvas>
        </div>

        <!-- All Squats Grid View -->
        <div class="all-squats-grid" id="allSquatsGrid">
        </div>
    </div>

    <!-- Bottom Controls -->
    <div class="bottom-controls">
        <button id="showAllBtn" onclick="toggleShowAll()">Show All</button>
        <button class="delete-all" onclick="deleteAllSquats()">Delete All</button>
    </div>
    </div>

    <script>
        /**
         * APP CONFIGURATION
         */
        const CONF = {
            videoWidth: 640,
            videoHeight: 480,
            flipHorizontal: true,
            minConfidence: 0.2, // Lowered from 0.5
            // Squat logic thresholds (in degrees)
            standThresh: 165, // Angle considered "Standing"
            squatThresh: 140, // Angle considered starting a squat
            deepThresh: 100,  // Just for visual feedback on deep squats
        };

        const SHOW_ALL_PREF_KEY = 'squatShowMode';

        /**
         * STATE MANAGEMENT
         */
        let state = {
            isDetecting: false,
            isSquatting: false,
            squatCount: 0,
            currentAngle: 180,
            // Buffer for the current squat data
            currentSquatData: [], 
            startTime: 0,
            animationFrameId: null,
            videoStream: null,
            detector: null,
            lastLogTime: 0,
            // History navigation
            currentHistoryIndex: 0,
            showAllView: false
        };

        // Placeholder for chart instances
        let liveChart;
        let historyChart; 

        /**
         * RESET LIVE DATA
         */
        function resetLiveData() {
            // Reset squat counting state
            state.isSquatting = false;
            state.squatCount = 0;
            state.currentSquatData = [];
            
            // Update display
            document.getElementById('countDisplay').innerText = '0';
            document.getElementById('statusDisplay').innerText = 'Standing';
            
            // Clear the live chart
            resetLiveChart();
        }

        /**
         * AUDIO FEEDBACK
         */
        function playSquatCompleteSound() {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.value = 800; // Frequency in Hz
                oscillator.type = 'sine'; // Smooth sine wave
                
                gainNode.gain.setValueAtTime(0.1, audioContext.currentTime); // Low volume (discrete)
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.1); // Short 100ms beep
            } catch (e) {
                console.warn('Audio playback failed:', e);
            }
        }

        /**
         * INITIALIZATION
         */
        async function setup() {
            initCharts();
            console.log("Loading MoveNet...");
            const detectorConfig = {
                modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING
            };
            state.detector = await poseDetection.createDetector(
                poseDetection.SupportedModels.MoveNet, 
                detectorConfig
            );
            console.log("MoveNet Loaded");
        }

        async function toggleDetection() {
            const instructionScreen = document.getElementById('instructionScreen');
            const stopOverlay = document.getElementById('stopOverlay');
            const statsOverlay = document.getElementById('statsOverlay');
            const loadingScreen = document.getElementById('loadingScreen');
            const loadingText = document.getElementById('loadingText');
            
            if (state.isDetecting) {
                // Stop detection
                saveCurrentSquatOnStop();
                state.isDetecting = false;
                document.getElementById('liveChartCard').classList.add('hidden');
                instructionScreen.classList.remove('hidden');
                stopOverlay.classList.add('hidden');
                statsOverlay.classList.add('hidden');
                loadingScreen.classList.add('hidden');
                if (state.animationFrameId) {
                    cancelAnimationFrame(state.animationFrameId);
                }
                if (state.videoStream) {
                    state.videoStream.getTracks().forEach(track => track.stop());
                }
                const canvas = document.getElementById('output');
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
            } else {
                // Start detection - Immediate UI Feedback
                instructionScreen.classList.add('hidden');
                loadingScreen.classList.remove('hidden');
                loadingText.innerText = "Initializing AI Model...";
                
                // Reveal the live chart card immediately to ensure page is tall enough to scroll
                document.getElementById('liveChartCard').classList.remove('hidden');

                // Scroll to position viewer container just below the header
                const headerContainer = document.querySelector('.header-container');
                const rect = headerContainer.getBoundingClientRect();
                const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
                
                // Scroll to the bottom of the header plus the gap (24px) + extra buffer
                // This ensures the header and its shadow are completely scrolled out of view
                const targetScroll = rect.bottom + scrollTop;

                window.scrollTo({
                    top: targetScroll,
                    behavior: 'smooth'
                });

                // Ensure detector is loaded before proceeding
                if (!state.detector) {
                    console.warn("Detector not loaded yet, waiting...");
                    while (!state.detector) {
                        await new Promise(resolve => setTimeout(resolve, 100));
                    }
                    console.log("Detector ready!");
                }

                state.isDetecting = true;
                loadingText.innerText = "Starting camera...";
                
                const video = document.getElementById('video');
                try {
                    state.videoStream = await navigator.mediaDevices.getUserMedia({
                        'audio': false,
                        'video': {
                            width: CONF.videoWidth,
                            height: CONF.videoHeight,
                            facingMode: 'user'
                        }
                    });
                    video.srcObject = state.videoStream;
                    loadingText.innerText = "Waiting for video stream...";

                    video.onloadedmetadata = () => {
                        CONF.videoWidth = video.videoWidth;
                        CONF.videoHeight = video.videoHeight;
                        const canvas = document.getElementById('output');
                        const ctx = canvas.getContext('2d');
                        canvas.width = CONF.videoWidth;
                        canvas.height = CONF.videoHeight;
                        detectPoseInRealTime(video, state.detector, ctx);
                    };
                } catch (e) {
                    console.error("Error starting video stream:", e);
                    state.isDetecting = false;
                    instructionScreen.classList.remove('hidden');
                    loadingScreen.classList.add('hidden');
                }
            }
        }
        
        /**
         * MAIN LOOP
         */
        function detectPoseInRealTime(video, detector, ctx) {
            async function poseDetectionFrame() {
                if (!state.isDetecting) return;

                if (video.readyState < 3) {
                    state.animationFrameId = requestAnimationFrame(poseDetectionFrame);
                    return;
                }

                // Hide loading screen if it's still visible and show overlays
                const loadingScreen = document.getElementById('loadingScreen');
                if (!loadingScreen.classList.contains('hidden')) {
                    loadingScreen.classList.add('hidden');
                    document.getElementById('stopOverlay').classList.remove('hidden');
                    document.getElementById('statsOverlay').classList.remove('hidden');
                }

                const poses = await detector.estimatePoses(video);
                if (poses.length === 0) {
                    state.animationFrameId = requestAnimationFrame(poseDetectionFrame);
                    return;
                }
                
                const pose = poses[0]; // Get first detected pose

                const now = Date.now();
                if (now - state.lastLogTime > 2000) {
                    console.log("Video readyState: ", video.readyState, " videoWidth: ", video.videoWidth, " videoHeight: ", video.videoHeight);
                    console.log("Full pose object:", pose);
                    
                    // Log nose first (keypoint index 0 in MoveNet)
                    const nose = pose.keypoints[0];
                    if (nose) {
                        console.log(`${nose.name}: score=${nose.score.toFixed(3)}, x=${Math.round(nose.x)}, y=${Math.round(nose.y)}`);
                    }
                    
                    // Log top 3 highest scoring keypoints
                    const sorted = [...pose.keypoints].sort((a, b) => b.score - a.score).slice(0, 3);
                    sorted.forEach(kp => {
                        console.log(`${kp.name}: score=${kp.score.toFixed(3)}, x=${Math.round(kp.x)}, y=${Math.round(kp.y)}`);
                    });
                    
                    state.lastLogTime = now;
                }

                ctx.clearRect(0, 0, CONF.videoWidth, CONF.videoHeight);
                ctx.save();
                
                // Apply mirror transform in canvas context
                ctx.scale(-1, 1);
                ctx.translate(-CONF.videoWidth, 0);
                
                ctx.drawImage(video, 0, 0, CONF.videoWidth, CONF.videoHeight);
                
                drawKeypoints(pose.keypoints, CONF.minConfidence, ctx);
                drawSkeleton(pose.keypoints, CONF.minConfidence, ctx);
                ctx.restore();

                processPose(pose);

                state.animationFrameId = requestAnimationFrame(poseDetectionFrame);
            }
            poseDetectionFrame();
        }

        /**
         * LOGIC: Angle Calculation & Squat State Machine
         */
        function processPose(pose) {
            // MoveNet keypoint indices: 11=left_hip, 12=right_hip, 13=left_knee, 14=right_knee, 15=left_ankle, 16=right_ankle
            const rightHip = pose.keypoints[12];
            const rightKnee = pose.keypoints[14];
            const rightAnkle = pose.keypoints[16];
            
            const leftHip = pose.keypoints[11];
            const leftKnee = pose.keypoints[13];
            const leftAnkle = pose.keypoints[15];

            const rightConf = (rightHip.score + rightKnee.score + rightAnkle.score) / 3;
            const leftConf = (leftHip.score + leftKnee.score + leftAnkle.score) / 3;

            const usableThreshold = 0.28;
            let hip, knee, ankle, confidence;

            if (rightConf > leftConf && rightConf >= usableThreshold) {
                [hip, knee, ankle] = [rightHip, rightKnee, rightAnkle];
                confidence = rightConf;
            } else if (leftConf >= usableThreshold) {
                [hip, knee, ankle] = [leftHip, leftKnee, leftAnkle];
                confidence = leftConf;
            } else {
                // Data not usable - show placeholders
                document.getElementById('angleDisplay').innerText = '-';
                document.getElementById('angleDisplay').style.color = 'var(--md-primary-dark)';
                document.getElementById('statusDisplay').innerText = '-';
                return;
            }

            const angle = calculateAngle({x: hip.x, y: hip.y}, {x: knee.x, y: knee.y}, {x: ankle.x, y: ankle.y});
            state.currentAngle = Math.round(angle);

            document.getElementById('angleDisplay').innerText = state.currentAngle + 'Â°';
            document.getElementById('angleDisplay').style.color = 'var(--md-primary-dark)';

            const now = Date.now();

            if (!state.isSquatting) {
                if (angle < CONF.squatThresh) {
                    state.isSquatting = true;
                    state.startTime = now;
                    state.currentSquatData = []; 
                    document.getElementById('statusDisplay').innerText = "Squatting...";
                    resetLiveChart();
                }
            }

            if (state.isSquatting) {
                const timeOffset = (now - state.startTime) / 1000;
                state.currentSquatData.push({ x: timeOffset, y: Math.round(angle) });
                
                updateLiveChart(timeOffset, Math.round(angle));

                if (angle > CONF.standThresh) {
                    state.isSquatting = false;
                    state.squatCount++;
                    document.getElementById('statusDisplay').innerText = "Standing";
                    document.getElementById('countDisplay').innerText = state.squatCount;
                    
                    pushToHistory(state.currentSquatData);
                    playSquatCompleteSound();
                }
            }
        }

        /**
         * MATH: Calculate angle between three points (A-B-C)
         */
        function calculateAngle(a, b, c) {
            const AB = Math.sqrt(Math.pow(b.x - a.x, 2) + Math.pow(b.y - a.y, 2));
            const BC = Math.sqrt(Math.pow(b.x - c.x, 2) + Math.pow(b.y - c.y, 2));
            const AC = Math.sqrt(Math.pow(c.x - a.x, 2) + Math.pow(c.y - a.y, 2));
            
            let radian = Math.acos((BC*BC+AB*AB-AC*AC)/(2*BC*AB));
            let degree = (radian * 180) / Math.PI;
            
            return degree; 
        }

        /**
         * CHARTING LOGIC
         */
        function initCharts() {
            const commonOptions = {
                responsive: true,
                animation: false, 
                scales: {
                    y: { 
                        beginAtZero: false, 
                        min: 0, // Changed from 40 to 0
                        max: 170, // Changed from 180 to 170
                        title: { display: true, text: 'Angle (Degrees)' }
                    },
                    x: {
                        type: 'linear',
                        title: { display: true, text: 'Time (s)' }
                    }
                },
                plugins: { legend: { display: false } }
            };

            const ctxLive = document.getElementById('liveChart').getContext('2d');
            liveChart = new Chart(ctxLive, {
                type: 'line',
                data: { datasets: [{ label: 'Live Angle', data: [], borderColor: 'rgb(75, 192, 192)', tension: 0.1 }] },
                options: commonOptions
            });

            const ctxHistory = document.getElementById('historyChart').getContext('2d');
            historyChart = new Chart(ctxHistory, {
                type: 'line',
                data: { datasets: [{ label: 'Squat', data: [], borderColor: '#ff6384', tension: 0.1 }] },
                options: {
                    responsive: true,
                    animation: false,
                    scales: {
                        y: { 
                            title: { display: true, text: 'Angle (Degrees)' }
                        },
                        x: {
                            type: 'linear',
                            title: { display: true, text: 'Time (s)' }
                        }
                    },
                    plugins: { legend: { display: false } }
                }
            });

            // Load history after all charts are initialized
            loadHistory();
        }

        function updateLiveChart(time, angle) {
            liveChart.data.datasets[0].data.push({x: time, y: angle});
            if(liveChart.data.datasets[0].data.length > 300) {
                liveChart.data.datasets[0].data.shift();
            }
            liveChart.update('none'); 
        }

        function resetLiveChart() {
            liveChart.data.datasets[0].data = [];
            liveChart.update();
        }

        function saveCurrentSquatOnStop() {
            if (!state.isSquatting || state.currentSquatData.length === 0) return;

            pushToHistory(state.currentSquatData);
            state.isSquatting = false;
            state.currentSquatData = [];
        }

        function pushToHistory(data) {
            const historyData = loadHistoryData() || [];

            historyData.unshift({
                timestamp: new Date().toISOString(),
                data: data
            });

            saveHistoryData(historyData);
            state.currentHistoryIndex = 0; // Show the newly added squat
            showHistorySquat(0);
        }

        function loadHistory() {
            const historyData = loadHistoryData();
            if (historyData && historyData.length > 0) {
                state.currentHistoryIndex = 0;
                showHistorySquat(0);
            }
        }

        function loadHistoryData() {
            const jsonData = localStorage.getItem('squatHistory');
            return jsonData ? JSON.parse(jsonData) : null;
        }

        function saveHistoryData(historyData) {
            localStorage.setItem('squatHistory', JSON.stringify(historyData));
        }

        function showHistorySquat(index) {
            const historyData = loadHistoryData() || [];
            
            if (historyData.length === 0) {
                document.getElementById('historyTitle').innerText = 'No Squats Recorded';
                document.getElementById('prevBtn').disabled = true;
                document.getElementById('nextBtn').disabled = true;
                document.getElementById('deleteBtn').disabled = true;
                historyChart.data.datasets[0].data = [];
                historyChart.update();
                return;
            }

            if (index < 0 || index >= historyData.length) {
                return;
            }

            state.currentHistoryIndex = index;
            const squat = historyData[index];
            const date = new Date(squat.timestamp);
            const day = String(date.getDate()).padStart(2, '0');
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const year = String(date.getFullYear()).slice(-2);
            const hour = String(date.getHours()).padStart(2, '0');
            const minute = String(date.getMinutes()).padStart(2, '0');
            const formattedDate = `${day}/${month}-${year} ${hour}:${minute}`;
            
            // Calculate min angle
            const minAngle = squat.data.length > 0 ? Math.round(Math.min(...squat.data.map(d => d.y))) : 0;
            const entryNumber = historyData.length - index;
            
            document.getElementById('historyTitle').innerHTML = `<span>Squat ${entryNumber} ${formattedDate}</span><span>Min ${minAngle}Â°</span>`;
            document.getElementById('prevBtn').disabled = index === 0;
            document.getElementById('nextBtn').disabled = index === historyData.length - 1;
            document.getElementById('deleteBtn').disabled = false;

            // Auto-scale the chart
            const data = squat.data;
            historyChart.data.datasets[0].data = data;
            
            if (data.length > 0) {
                const yValues = data.map(d => d.y);
                const xValues = data.map(d => d.x);
                const yMin = Math.max(0, Math.min(...yValues) - 10);
                const yMax = Math.min(180, Math.max(...yValues) + 10);
                const xMin = 0;
                const xMax = Math.max(...xValues) + 0.5;

                historyChart.options.scales.y.min = yMin;
                historyChart.options.scales.y.max = yMax;
                historyChart.options.scales.x.min = xMin;
                historyChart.options.scales.x.max = xMax;
            }

            historyChart.update();
        }

        function navigateHistory(direction) {
            const historyData = loadHistoryData() || [];
            const newIndex = state.currentHistoryIndex + direction;
            
            if (newIndex >= 0 && newIndex < historyData.length) {
                showHistorySquat(newIndex);
            }
        }

        function deleteCurrentSquat() {
            deleteSquatAt(state.currentHistoryIndex);
        }

        function deleteSquatAt(index) {
            const historyData = loadHistoryData() || [];

            if (historyData.length === 0) return;
            if (index < 0 || index >= historyData.length) return;

            if (!confirm('Delete this squat recording?')) return;

            historyData.splice(index, 1);
            saveHistoryData(historyData);

            if (historyData.length === 0) {
                state.currentHistoryIndex = 0;
                showHistorySquat(0);
            } else {
                if (state.currentHistoryIndex >= historyData.length) {
                    state.currentHistoryIndex = Math.max(0, historyData.length - 1);
                } else if (index < state.currentHistoryIndex) {
                    state.currentHistoryIndex = Math.max(0, state.currentHistoryIndex - 1);
                }
                showHistorySquat(state.currentHistoryIndex);
            }

            if (state.showAllView) {
                renderAllSquats();
            }
        }

        function toggleShowAll() {
            const nextMode = !state.showAllView;
            state.showAllView = nextMode;
            saveShowModePreference(nextMode);
            applyShowModePreference();
        }

        function applyShowModePreference() {
            const historyViewer = document.getElementById('historyViewer');
            const allSquatsGrid = document.getElementById('allSquatsGrid');
            const showAllBtn = document.getElementById('showAllBtn');
            const bottomControls = document.querySelector('.bottom-controls');
            const chartsWrapper = document.querySelector('.charts-wrapper');

            if (state.showAllView) {
                historyViewer.classList.add('hidden');
                allSquatsGrid.classList.add('visible');
                showAllBtn.innerText = 'Show Last';
                chartsWrapper.insertBefore(bottomControls, allSquatsGrid);
                renderAllSquats();
            } else {
                historyViewer.classList.remove('hidden');
                allSquatsGrid.classList.remove('visible');
                showAllBtn.innerText = 'Show All';
                chartsWrapper.parentNode.insertBefore(bottomControls, chartsWrapper.nextSibling);
            }
        }

        function saveShowModePreference(value) {
            try {
                localStorage.setItem(SHOW_ALL_PREF_KEY, value ? 'true' : 'false');
            } catch (e) {
                console.warn('Could not persist show mode preference:', e);
            }
        }

        function restoreShowModePreference() {
            try {
                const stored = localStorage.getItem(SHOW_ALL_PREF_KEY);
                if (stored === null) return;
                state.showAllView = stored === 'true';
                applyShowModePreference();
            } catch (e) {
                console.warn('Could not load show mode preference:', e);
            }
        }

        function renderAllSquats() {
            const historyData = loadHistoryData() || [];
            const container = document.getElementById('allSquatsGrid');
            container.innerHTML = '';

            if (historyData.length === 0) {
                container.innerHTML = '<p style="grid-column: 1/-1; text-align: center; padding: 20px;">No squats recorded yet</p>';
                return;
            }

            historyData.forEach((squat, index) => {
                const date = new Date(squat.timestamp);
                const day = String(date.getDate()).padStart(2, '0');
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const year = String(date.getFullYear()).slice(-2);
                const hour = String(date.getHours()).padStart(2, '0');
                const minute = String(date.getMinutes()).padStart(2, '0');
                const formattedDate = `${day}/${month}-${year} ${hour}:${minute}`;
                
                // Calculate min angle
                const minAngle = squat.data.length > 0 ? Math.round(Math.min(...squat.data.map(d => d.y))) : 0;
                
                const entryNumber = historyData.length - index;
                const card = document.createElement('div');
                card.className = 'chart-card show-all-card';
                card.innerHTML = `
                    <button class="delete-btn card-delete-btn" title="Delete this squat" onclick="deleteSquatAt(${index})">ðŸ—‘</button>
                    <h4 style="font-size: 0.9em; display: flex; justify-content: space-between; align-items: center; margin-top: 0.33em; margin-bottom: 0.5em;"><span>Squat ${entryNumber} ${formattedDate}</span><span>Min ${minAngle}Â°</span></h4>
                    <canvas id="allSquatChart${index}"></canvas>
                `;
                container.appendChild(card);

                // Create chart for this squat
                setTimeout(() => {
                    const ctx = document.getElementById(`allSquatChart${index}`).getContext('2d');
                    const data = squat.data;
                    
                    let yMin = 0, yMax = 170, xMin = 0, xMax = 10;
                    if (data.length > 0) {
                        const yValues = data.map(d => d.y);
                        const xValues = data.map(d => d.x);
                        yMin = Math.max(0, Math.min(...yValues) - 10);
                        yMax = Math.min(180, Math.max(...yValues) + 10);
                        xMin = 0;
                        xMax = Math.max(...xValues) + 0.5;
                    }

                    new Chart(ctx, {
                        type: 'line',
                        data: { 
                            datasets: [{ 
                                label: 'Squat', 
                                data: data, 
                                borderColor: '#ff6384', 
                                tension: 0.1 
                            }] 
                        },
                        options: {
                            responsive: true,
                            animation: false,
                            scales: {
                                y: { 
                                    min: yMin,
                                    max: yMax,
                                    title: { display: true, text: 'Angle (Â°)' }
                                },
                                x: {
                                    type: 'linear',
                                    min: xMin,
                                    max: xMax,
                                    title: { display: true, text: 'Time (s)' }
                                }
                            },
                            plugins: { legend: { display: false } }
                        }
                    });
                }, 0);
            });
        }

        function deleteAllSquats() {
            const historyData = loadHistoryData() || [];
            
            if (historyData.length === 0) {
                alert('No squats to delete');
                return;
            }

            if (!confirm(`Delete all ${historyData.length} squat recordings? This cannot be undone.`)) {
                return;
            }

            localStorage.removeItem('squatHistory');
            state.currentHistoryIndex = 0;
            showHistorySquat(0);

            if (state.showAllView) {
                renderAllSquats();
            }
        }

        /**
         * DRAWING HELPERS (MoveNet compatible)
         */
        function drawKeypoints(keypoints, minConfidence, ctx) {
            keypoints.forEach((keypoint) => {
                if (keypoint.score >= minConfidence) {
                    ctx.beginPath();
                    ctx.arc(keypoint.x, keypoint.y, 5, 0, 2 * Math.PI);
                    ctx.fillStyle = '#00ffcc';
                    ctx.fill();
                }
            });
        }

        function drawSkeleton(keypoints, minConfidence, ctx) {
            // MoveNet skeleton connections
            const connections = [
                [0, 1], [0, 2], [1, 3], [2, 4], // face
                [5, 6], [5, 7], [7, 9], [6, 8], [8, 10], // arms
                [5, 11], [6, 12], [11, 12], // torso
                [11, 13], [13, 15], [12, 14], [14, 16] // legs
            ];
            
            connections.forEach(([i, j]) => {
                const kp1 = keypoints[i];
                const kp2 = keypoints[j];
                
                if (kp1.score >= minConfidence && kp2.score >= minConfidence) {
                    ctx.beginPath();
                    ctx.moveTo(kp1.x, kp1.y);
                    ctx.lineTo(kp2.x, kp2.y);
                    ctx.lineWidth = 2;
                    ctx.strokeStyle = '#00ffcc';
                    ctx.stroke();
                }
            });
        }

        // Start App
        setup();
        restoreShowModePreference();

    </script>
    <script>
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/sw.js').then(registration => {
                    console.log('ServiceWorker registration successful with scope: ', registration.scope);
                }, err => {
                    console.log('ServiceWorker registration failed: ', err);
                });
            });
        }
    </script>
</body>
</html>