<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="manifest" href="manifest.json">
    <title>Squat Monitor - MoveNet</title>
    
    <!-- Load TensorFlow.js -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <!-- Load MoveNet -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection"></script>
    <!-- Load Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f0f2f5;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        h1 { margin-bottom: 5px; font-size: 1em; }

        .header-container {
            width: 100%;
            max-width: 640px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        /* Container for the live view */
        .viewer-container {
            position: relative;
            width: 100%; /* Take full width of its parent */
            max-width: 640px; /* Max width as before */
            padding-top: 75%; /* 4:3 Aspect Ratio (480 / 640 = 0.75) */
            height: 0; /* Important for padding-top trick */
            background: #000;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }

        video, canvas#output {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        video {
            display: none; /* Hidden, we draw to canvas */
        }

        .stats-overlay {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: #00ffcc;
            padding: 10px;
            border-radius: 4px;
            font-size: 18px;
            z-index: 10;
            pointer-events: none;
        }

        /* Layout for charts */
        .charts-wrapper {
            width: 100%;
            max-width: 1000px;
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px;
        }

        .chart-card {
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        .history-viewer {
            margin-top: 20px;
            display: block;
        }

        .history-viewer.hidden {
            display: none;
        }

        .history-controls {
            display: flex;
            flex-direction: column-reverse;
            gap: 8px;
            margin-bottom: 10px;
        }

        .history-controls h4 {
            margin: 0;
        }

        .nav-buttons {
            display: flex;
            gap: 8px;
            justify-content: flex-end;
        }

        .nav-buttons button, .delete-btn {
            padding: 4px 10px;
            font-size: 18px;
            cursor: pointer;
            border: none;
            border-radius: 4px;
            background: #007bff;
            color: white;
            min-width: 36px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .nav-buttons button:hover, .delete-btn:hover {
            background: #0056b3;
        }

        .nav-buttons button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .delete-btn {
            background: #dc3545;
        }

        .delete-btn:hover {
            background: #c82333;
        }

        .all-squats-grid {
            display: none;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .all-squats-grid.visible {
            display: grid;
        }

        .bottom-controls {
            width: 100%;
            max-width: 1000px;
            margin-top: 20px;
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .bottom-controls button {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            border: none;
            border-radius: 4px;
            background: #28a745;
            color: white;
        }

        .bottom-controls button:hover {
            background: #218838;
        }

        .bottom-controls button.delete-all {
            background: #dc3545;
        }

        .bottom-controls button.delete-all:hover {
            background: #c82333;
        }

        @media (max-width: 800px) {
            .viewer-container { width: 100%; height: auto; aspect-ratio: 4/3; }
            canvas#output { width: 100%; height: 100%; }
            .all-squats-grid { grid-template-columns: 1fr; }
        }

        .version {
            font-size: 10px;
            color: #888;
        }
    </style>
</head>
<body>
    <div class="header-container">
        <h1>Squat Angle Monitor</h1>
        <div class="version">v.1.0.1</div>
    </div>
    
    <button id="startStopButton">Start</button>

    <!-- Live Viewer -->
    <div class="viewer-container">
        <div class="stats-overlay">
            <div>Knee Angle: <span id="angleDisplay">0</span>Â°</div>
            <div>Status: <span id="statusDisplay">Standing</span></div>
            <div>Squats: <span id="countDisplay">0</span></div>
        </div>
        <video id="video" autoplay playsinline></video>
        <canvas id="output"></canvas>
    </div>

    <div class="charts-wrapper">
        <!-- Real-time graph for current squat -->
        <div class="chart-card">
            <h3>Current / Live Squat</h3>
            <canvas id="liveChart"></canvas>
        </div>

        <!-- Single History Viewer -->
        <div class="chart-card history-viewer" id="historyViewer">
            <div class="history-controls">
                <h4 id="historyTitle">No Squats Recorded</h4>
                <div class="nav-buttons">
                    <button id="prevBtn" onclick="navigateHistory(-1)" title="Previous">â¬†</button>
                    <button id="nextBtn" onclick="navigateHistory(1)" title="Next">â¬‡</button>
                    <button class="delete-btn" id="deleteBtn" onclick="deleteCurrentSquat()" title="Delete">ðŸ—‘</button>
                </div>
            </div>
            <canvas id="historyChart"></canvas>
        </div>

        <!-- All Squats Grid View -->
        <div class="all-squats-grid" id="allSquatsGrid">
        </div>
    </div>

    <!-- Bottom Controls -->
    <div class="bottom-controls">
        <button id="showAllBtn" onclick="toggleShowAll()">Show All</button>
        <button class="delete-all" onclick="deleteAllSquats()">Delete All</button>
    </div>

    <script>
        /**
         * APP CONFIGURATION
         */
        const CONF = {
            videoWidth: 640,
            videoHeight: 480,
            flipHorizontal: true,
            minConfidence: 0.2, // Lowered from 0.5
            // Squat logic thresholds (in degrees)
            standThresh: 165, // Angle considered "Standing"
            squatThresh: 140, // Angle considered starting a squat
            deepThresh: 100,  // Just for visual feedback on deep squats
        };

        /**
         * STATE MANAGEMENT
         */
        let state = {
            isDetecting: false,
            isSquatting: false,
            squatCount: 0,
            currentAngle: 180,
            // Buffer for the current squat data
            currentSquatData: [], 
            startTime: 0,
            animationFrameId: null,
            videoStream: null,
            detector: null,
            lastLogTime: 0,
            // History navigation
            currentHistoryIndex: 0,
            showAllView: false
        };

        // Placeholder for chart instances
        let liveChart;
        let historyChart; 

        const startStopButton = document.getElementById('startStopButton');
        startStopButton.onclick = toggleDetection;

        /**
         * INITIALIZATION
         */
        async function setup() {
            initCharts();
            console.log("Loading MoveNet...");
            const detectorConfig = {
                modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING
            };
            state.detector = await poseDetection.createDetector(
                poseDetection.SupportedModels.MoveNet, 
                detectorConfig
            );
            console.log("MoveNet Loaded");
        }

        async function toggleDetection() {
            if (state.isDetecting) {
                // Stop detection
                state.isDetecting = false;
                startStopButton.innerText = 'Start';
                if (state.animationFrameId) {
                    cancelAnimationFrame(state.animationFrameId);
                }
                if (state.videoStream) {
                    state.videoStream.getTracks().forEach(track => track.stop());
                }
                const canvas = document.getElementById('output');
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
            } else {
                // Start detection
                state.isDetecting = true;
                startStopButton.innerText = 'Stop';
                const video = document.getElementById('video');
                try {
                    state.videoStream = await navigator.mediaDevices.getUserMedia({
                        'audio': false,
                        'video': {
                            width: CONF.videoWidth,
                            height: CONF.videoHeight,
                            facingMode: 'user'
                        }
                    });
                    video.srcObject = state.videoStream;

                    video.onloadedmetadata = () => {
                        CONF.videoWidth = video.videoWidth;
                        CONF.videoHeight = video.videoHeight;
                        const canvas = document.getElementById('output');
                        const ctx = canvas.getContext('2d');
                        canvas.width = CONF.videoWidth;
                        canvas.height = CONF.videoHeight;
                        detectPoseInRealTime(video, state.detector, ctx);
                    };
                } catch (e) {
                    console.error("Error starting video stream:", e);
                    state.isDetecting = false;
                    startStopButton.innerText = 'Start';
                }
            }
        }
        
        /**
         * MAIN LOOP
         */
        function detectPoseInRealTime(video, detector, ctx) {
            async function poseDetectionFrame() {
                if (!state.isDetecting) return;

                if (video.readyState < 3) {
                    state.animationFrameId = requestAnimationFrame(poseDetectionFrame);
                    return;
                }

                const poses = await detector.estimatePoses(video);
                if (poses.length === 0) {
                    state.animationFrameId = requestAnimationFrame(poseDetectionFrame);
                    return;
                }
                
                const pose = poses[0]; // Get first detected pose

                const now = Date.now();
                if (now - state.lastLogTime > 2000) {
                    console.log("Video readyState: ", video.readyState, " videoWidth: ", video.videoWidth, " videoHeight: ", video.videoHeight);
                    console.log("Full pose object:", pose);
                    
                    // Log nose first (keypoint index 0 in MoveNet)
                    const nose = pose.keypoints[0];
                    if (nose) {
                        console.log(`${nose.name}: score=${nose.score.toFixed(3)}, x=${Math.round(nose.x)}, y=${Math.round(nose.y)}`);
                    }
                    
                    // Log top 3 highest scoring keypoints
                    const sorted = [...pose.keypoints].sort((a, b) => b.score - a.score).slice(0, 3);
                    sorted.forEach(kp => {
                        console.log(`${kp.name}: score=${kp.score.toFixed(3)}, x=${Math.round(kp.x)}, y=${Math.round(kp.y)}`);
                    });
                    
                    state.lastLogTime = now;
                }

                ctx.clearRect(0, 0, CONF.videoWidth, CONF.videoHeight);
                ctx.save();
                
                // Apply mirror transform in canvas context
                ctx.scale(-1, 1);
                ctx.translate(-CONF.videoWidth, 0);
                
                ctx.drawImage(video, 0, 0, CONF.videoWidth, CONF.videoHeight);
                
                drawKeypoints(pose.keypoints, CONF.minConfidence, ctx);
                drawSkeleton(pose.keypoints, CONF.minConfidence, ctx);
                ctx.restore();

                processPose(pose);

                state.animationFrameId = requestAnimationFrame(poseDetectionFrame);
            }
            poseDetectionFrame();
        }

        /**
         * LOGIC: Angle Calculation & Squat State Machine
         */
        function processPose(pose) {
            // MoveNet keypoint indices: 11=left_hip, 12=right_hip, 13=left_knee, 14=right_knee, 15=left_ankle, 16=right_ankle
            const rightHip = pose.keypoints[12];
            const rightKnee = pose.keypoints[14];
            const rightAnkle = pose.keypoints[16];
            
            const leftHip = pose.keypoints[11];
            const leftKnee = pose.keypoints[13];
            const leftAnkle = pose.keypoints[15];

            const rightConf = (rightHip.score + rightKnee.score + rightAnkle.score) / 3;
            const leftConf = (leftHip.score + leftKnee.score + leftAnkle.score) / 3;

            let hip, knee, ankle;

            if (rightConf > leftConf && rightConf > CONF.minConfidence) {
                [hip, knee, ankle] = [rightHip, rightKnee, rightAnkle];
            } else if (leftConf > CONF.minConfidence) {
                [hip, knee, ankle] = [leftHip, leftKnee, leftAnkle];
            } else {
                return;
            }

            const angle = calculateAngle({x: hip.x, y: hip.y}, {x: knee.x, y: knee.y}, {x: ankle.x, y: ankle.y});
            state.currentAngle = Math.round(angle);

            document.getElementById('angleDisplay').innerText = state.currentAngle;
            document.getElementById('angleDisplay').style.color = state.currentAngle < CONF.deepThresh ? '#00ff00' : '#00ffcc';

            const now = Date.now();

            if (!state.isSquatting) {
                if (angle < CONF.squatThresh) {
                    state.isSquatting = true;
                    state.startTime = now;
                    state.currentSquatData = []; 
                    document.getElementById('statusDisplay').innerText = "Squatting...";
                    resetLiveChart();
                }
            }

            if (state.isSquatting) {
                const timeOffset = (now - state.startTime) / 1000;
                state.currentSquatData.push({ x: timeOffset, y: Math.round(angle) });
                
                updateLiveChart(timeOffset, Math.round(angle));

                if (angle > CONF.standThresh) {
                    state.isSquatting = false;
                    state.squatCount++;
                    document.getElementById('statusDisplay').innerText = "Standing";
                    document.getElementById('countDisplay').innerText = state.squatCount;
                    
                    pushToHistory(state.currentSquatData);
                }
            }
        }

        /**
         * MATH: Calculate angle between three points (A-B-C)
         */
        function calculateAngle(a, b, c) {
            const AB = Math.sqrt(Math.pow(b.x - a.x, 2) + Math.pow(b.y - a.y, 2));
            const BC = Math.sqrt(Math.pow(b.x - c.x, 2) + Math.pow(b.y - c.y, 2));
            const AC = Math.sqrt(Math.pow(c.x - a.x, 2) + Math.pow(c.y - a.y, 2));
            
            let radian = Math.acos((BC*BC+AB*AB-AC*AC)/(2*BC*AB));
            let degree = (radian * 180) / Math.PI;
            
            return degree; 
        }

        /**
         * CHARTING LOGIC
         */
        function initCharts() {
            const commonOptions = {
                responsive: true,
                animation: false, 
                scales: {
                    y: { 
                        beginAtZero: false, 
                        min: 0, // Changed from 40 to 0
                        max: 170, // Changed from 180 to 170
                        title: { display: true, text: 'Angle (Degrees)' }
                    },
                    x: {
                        type: 'linear',
                        title: { display: true, text: 'Time (s)' }
                    }
                },
                plugins: { legend: { display: false } }
            };

            const ctxLive = document.getElementById('liveChart').getContext('2d');
            liveChart = new Chart(ctxLive, {
                type: 'line',
                data: { datasets: [{ label: 'Live Angle', data: [], borderColor: 'rgb(75, 192, 192)', tension: 0.1 }] },
                options: commonOptions
            });

            const ctxHistory = document.getElementById('historyChart').getContext('2d');
            historyChart = new Chart(ctxHistory, {
                type: 'line',
                data: { datasets: [{ label: 'Squat', data: [], borderColor: '#ff6384', tension: 0.1 }] },
                options: {
                    responsive: true,
                    animation: false,
                    scales: {
                        y: { 
                            title: { display: true, text: 'Angle (Degrees)' }
                        },
                        x: {
                            type: 'linear',
                            title: { display: true, text: 'Time (s)' }
                        }
                    },
                    plugins: { legend: { display: false } }
                }
            });

            // Load history after all charts are initialized
            loadHistory();
        }

        function updateLiveChart(time, angle) {
            liveChart.data.datasets[0].data.push({x: time, y: angle});
            if(liveChart.data.datasets[0].data.length > 300) {
                liveChart.data.datasets[0].data.shift();
            }
            liveChart.update('none'); 
        }

        function resetLiveChart() {
            liveChart.data.datasets[0].data = [];
            liveChart.update();
        }

        function pushToHistory(data) {
            const historyData = loadHistoryData() || [];

            historyData.unshift({
                timestamp: new Date().toISOString(),
                data: data
            });

            saveHistoryData(historyData);
            state.currentHistoryIndex = 0; // Show the newly added squat
            showHistorySquat(0);
        }

        function loadHistory() {
            const historyData = loadHistoryData();
            if (historyData && historyData.length > 0) {
                state.currentHistoryIndex = 0;
                showHistorySquat(0);
            }
        }

        function loadHistoryData() {
            const jsonData = localStorage.getItem('squatHistory');
            return jsonData ? JSON.parse(jsonData) : null;
        }

        function saveHistoryData(historyData) {
            localStorage.setItem('squatHistory', JSON.stringify(historyData));
        }

        function showHistorySquat(index) {
            const historyData = loadHistoryData() || [];
            
            if (historyData.length === 0) {
                document.getElementById('historyTitle').innerText = 'No Squats Recorded';
                document.getElementById('prevBtn').disabled = true;
                document.getElementById('nextBtn').disabled = true;
                document.getElementById('deleteBtn').disabled = true;
                historyChart.data.datasets[0].data = [];
                historyChart.update();
                return;
            }

            if (index < 0 || index >= historyData.length) {
                return;
            }

            state.currentHistoryIndex = index;
            const squat = historyData[index];
            const date = new Date(squat.timestamp);
            const formattedDate = date.toLocaleDateString() + ' ' + date.toLocaleTimeString();
            
            document.getElementById('historyTitle').innerText = `Squat ${index + 1} of ${historyData.length} - ${formattedDate}`;
            document.getElementById('prevBtn').disabled = index === 0;
            document.getElementById('nextBtn').disabled = index === historyData.length - 1;
            document.getElementById('deleteBtn').disabled = false;

            // Auto-scale the chart
            const data = squat.data;
            historyChart.data.datasets[0].data = data;
            
            if (data.length > 0) {
                const yValues = data.map(d => d.y);
                const xValues = data.map(d => d.x);
                const yMin = Math.max(0, Math.min(...yValues) - 10);
                const yMax = Math.min(180, Math.max(...yValues) + 10);
                const xMin = 0;
                const xMax = Math.max(...xValues) + 0.5;

                historyChart.options.scales.y.min = yMin;
                historyChart.options.scales.y.max = yMax;
                historyChart.options.scales.x.min = xMin;
                historyChart.options.scales.x.max = xMax;
            }

            historyChart.update();
        }

        function navigateHistory(direction) {
            const historyData = loadHistoryData() || [];
            const newIndex = state.currentHistoryIndex + direction;
            
            if (newIndex >= 0 && newIndex < historyData.length) {
                showHistorySquat(newIndex);
            }
        }

        function deleteCurrentSquat() {
            const historyData = loadHistoryData() || [];
            
            if (historyData.length === 0) return;
            
            if (!confirm('Delete this squat recording?')) return;

            historyData.splice(state.currentHistoryIndex, 1);
            saveHistoryData(historyData);

            // Show the same index (or previous if we deleted the last one)
            if (state.currentHistoryIndex >= historyData.length) {
                state.currentHistoryIndex = Math.max(0, historyData.length - 1);
            }

            if (historyData.length > 0) {
                showHistorySquat(state.currentHistoryIndex);
            } else {
                showHistorySquat(0); // Will show "No Squats Recorded"
            }

            // Update all-squats view if it's visible
            if (state.showAllView) {
                renderAllSquats();
            }
        }

        function toggleShowAll() {
            state.showAllView = !state.showAllView;
            const historyViewer = document.getElementById('historyViewer');
            const allSquatsGrid = document.getElementById('allSquatsGrid');
            const showAllBtn = document.getElementById('showAllBtn');

            if (state.showAllView) {
                historyViewer.classList.add('hidden');
                allSquatsGrid.classList.add('visible');
                showAllBtn.innerText = 'Show Navigator';
                renderAllSquats();
            } else {
                historyViewer.classList.remove('hidden');
                allSquatsGrid.classList.remove('visible');
                showAllBtn.innerText = 'Show All';
            }
        }

        function renderAllSquats() {
            const historyData = loadHistoryData() || [];
            const container = document.getElementById('allSquatsGrid');
            container.innerHTML = '';

            if (historyData.length === 0) {
                container.innerHTML = '<p style="grid-column: 1/-1; text-align: center; padding: 20px;">No squats recorded yet</p>';
                return;
            }

            historyData.forEach((squat, index) => {
                const date = new Date(squat.timestamp);
                const formattedDate = date.toLocaleDateString() + ' ' + date.toLocaleTimeString();
                
                const card = document.createElement('div');
                card.className = 'chart-card';
                card.innerHTML = `
                    <h4>Squat ${index + 1} - ${formattedDate}</h4>
                    <canvas id="allSquatChart${index}"></canvas>
                `;
                container.appendChild(card);

                // Create chart for this squat
                setTimeout(() => {
                    const ctx = document.getElementById(`allSquatChart${index}`).getContext('2d');
                    const data = squat.data;
                    
                    let yMin = 0, yMax = 170, xMin = 0, xMax = 10;
                    if (data.length > 0) {
                        const yValues = data.map(d => d.y);
                        const xValues = data.map(d => d.x);
                        yMin = Math.max(0, Math.min(...yValues) - 10);
                        yMax = Math.min(180, Math.max(...yValues) + 10);
                        xMin = 0;
                        xMax = Math.max(...xValues) + 0.5;
                    }

                    new Chart(ctx, {
                        type: 'line',
                        data: { 
                            datasets: [{ 
                                label: 'Squat', 
                                data: data, 
                                borderColor: '#ff6384', 
                                tension: 0.1 
                            }] 
                        },
                        options: {
                            responsive: true,
                            animation: false,
                            scales: {
                                y: { 
                                    min: yMin,
                                    max: yMax,
                                    title: { display: true, text: 'Angle (Â°)' }
                                },
                                x: {
                                    type: 'linear',
                                    min: xMin,
                                    max: xMax,
                                    title: { display: true, text: 'Time (s)' }
                                }
                            },
                            plugins: { legend: { display: false } }
                        }
                    });
                }, 0);
            });
        }

        function deleteAllSquats() {
            const historyData = loadHistoryData() || [];
            
            if (historyData.length === 0) {
                alert('No squats to delete');
                return;
            }

            if (!confirm(`Delete all ${historyData.length} squat recordings? This cannot be undone.`)) {
                return;
            }

            localStorage.removeItem('squatHistory');
            state.currentHistoryIndex = 0;
            showHistorySquat(0);

            if (state.showAllView) {
                renderAllSquats();
            }
        }

        /**
         * DRAWING HELPERS (MoveNet compatible)
         */
        function drawKeypoints(keypoints, minConfidence, ctx) {
            keypoints.forEach((keypoint) => {
                if (keypoint.score >= minConfidence) {
                    ctx.beginPath();
                    ctx.arc(keypoint.x, keypoint.y, 5, 0, 2 * Math.PI);
                    ctx.fillStyle = '#00ffcc';
                    ctx.fill();
                }
            });
        }

        function drawSkeleton(keypoints, minConfidence, ctx) {
            // MoveNet skeleton connections
            const connections = [
                [0, 1], [0, 2], [1, 3], [2, 4], // face
                [5, 6], [5, 7], [7, 9], [6, 8], [8, 10], // arms
                [5, 11], [6, 12], [11, 12], // torso
                [11, 13], [13, 15], [12, 14], [14, 16] // legs
            ];
            
            connections.forEach(([i, j]) => {
                const kp1 = keypoints[i];
                const kp2 = keypoints[j];
                
                if (kp1.score >= minConfidence && kp2.score >= minConfidence) {
                    ctx.beginPath();
                    ctx.moveTo(kp1.x, kp1.y);
                    ctx.lineTo(kp2.x, kp2.y);
                    ctx.lineWidth = 2;
                    ctx.strokeStyle = '#00ffcc';
                    ctx.stroke();
                }
            });
        }

        // Start App
        setup();

    </script>
    <script>
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/sw.js').then(registration => {
                    console.log('ServiceWorker registration successful with scope: ', registration.scope);
                }, err => {
                    console.log('ServiceWorker registration failed: ', err);
                });
            });
        }
    </script>
</body>
</html>